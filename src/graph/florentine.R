remove(list = ls())
library(igraph)

library('netrankr')


#load the florentine family graph and assign as g1
data("florentine_m")

g1 <- florentine_m
str(g1, v=F)
#get the vertex and edges sequences

V(g1)
vcount((g1))
E(g1)
ecount(g1)

g1 <-(9--12)
### show the whealth attributes for each vertex
V(g1)$wealth
as.data.frame(V(g1)$wealth, rownames(V(g1)))

#write_the_graph as edgelist
write.graph(g1,'data/graph/florentinefamily.csv', format = 'edgelist')



#check if the graph is connected
#connected means that any two vertices are reachable from each other with a multi-hop path
#i.e. not isolated vertices

is.connected(g1)




#delete Florentine families with a Null degree
g1.1 <- delete_vertices(g1,which(degree(g1)==0))

is.connected(g1.1)




#plot the simplegraph of florentine families, plot size of vertices by degree of vertex * 6
plot(g1,vertex.size=degree(florentine_m)*6)

#plot the simplegraph of florentine families, plot size of vertices by degree of vertex * 6
plot.igraph(g1,
     vertex.label.cex=V(g1)$wealth*0.04, 
     vertex.label.color="black",
     vertex.color="white",
     vertex.frame.color="gray")


#plot with a different layout
help('layout_')

ffl <- layout_(g1, layout = with_kk())

plot(g1,vertex.size=degree(florentine_m)*6, layout=ffl)



# Get the Diameter of a graph
#The diameter of a graph is the length of the longest geodesic. 
diameter(g1, directed=F)
diam <- get_diameter(g1, directed=F)
diam



# Get the degree of the graph and plot the graph based the value of the degree, 
# then plot the histogram

# note
# DEGREE OF A NODE depends if we have a directed or undirected graph
# if we have a directed one the in degree and the out degree (edges out of vertex)
# are often different, while if undirected we have bidirectional edges and then
# they are equal

#High degree nodes attract a lot of connections
# They are hubs, very important for the functioning of the network

#Killing high degree nodes may be much more serious than killing low degree
#nodes

# ==========
deg <- degree(g1, mode="all")
plot.igraph(g1,
            vertex.size=deg*5, 
            vertex.label.color="black",
            vertex.color="red",
            vertex.frame.color="gray")


hist(deg, breaks=1:vcount(g1)-1, main="Histogram of node degree")


# Degree distribution
# rember that degree of a vertex is its most basic structural property, 
# the number of its adjacent edges.
 
# notes on DD
 
# The degrees of vertices are a fundamental network property, 
# and correlate with or drive many other
# kinds of network patterns. A key question in network analysis is thus
# How much of some observed pattern is generated by the degrees alone?
 
#  That is, high-degree vertices appear much more often than
#  we would naively expect.

#The shape of the degree distribution is of general interest in network science

deg.dist <- degree_distribution(g1, cumulative=T, mode="all")
plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange", xlab="Degree", ylab="Cumulative Frequency")
#The cumulate says that the probability that a degree observed is lower than a value


# Calculate the average path length of the graph and all possible distances

mean_distance(g1, directed=F)

distances(g1)


#calculate some basic centrality measures of the graph

## CENTRALITY MEASURES ##----

##Calculate Eigenvector centrality measure and plot it in a proper
## way with proper color

#Eigenvector centrality measures is similar to the concept of the google page rank
#it assignes to a vertex teh importance score proportional to the importance score 
#of its neighbor



options(digits=4)
eigencen = eigen_centrality(g1)$vector
sort(eigencen, decreasing = T)

bins <- unique(quantile(eigencen, seq(0,1,length.out=30)))
# cut identifies the corresponding bin for each score
vals <- cut(eigencen, bins, labels=FALSE, include.lowest=TRUE)
length(vals); head(vals)

#then we will assignt the color of each bin to a variable
my_col = heat.colors(length(bins))
head(my_col)
colorVals <- rev(my_col)[vals]

V(g1)$color <- colorVals
set.seed(1)
plot.igraph(g1, vertex.size=5, 
            vertex.label.cex=V(g1)$wealth*0.011, 
            vertex.label.color="black",
            vertex.frame.color="gray")

subgraph = subgraph_centrality(g1)

#calculate betweenees centrality measure, 
#find its correlation with the eigenvector centrality
#plot it properly

#The bewtenees centrality says how much paths between 
#any other nodes go trought that node
#

#This idea is based,
#in part, on a seminal 
#paper by Mark Granovetter called “The strength of weak ties”13 in which
#it was shown that most job seekers (who participated in the study)
#found their ultimate employment through a weak tie, that is, 
#through an acquaintance, rather than a strong tie or a close friend.

betwenness = betwenness(g1)

sort(betwenness,decreasing=TRUE)[1:10]

cor(betwenness,eigencen)


bins <- unique(quantile(betwenness, seq(0,1,length.out=30)))
vals <- cut(betwenness, bins, labels=FALSE, include.lowest=TRUE)

colorVals <- rev(terrain.colors(length(bins)))[vals]
V(g1)$color <- colorVals
set.seed(1)
plot.igraph(g1, vertex.size=V(g1)$wealth/10, 
            vertex.label.cex=V(g1)$wealth*0.011, 
            vertex.label.color="black")


## CLUSTERING MEASURES---

# Calculate the Edge betwenees centrality measure it 
# is basically a clustering measure and plot it
# The measure helps to find the community, and isolate them,

# ==========
w <- edge.betweenness.community(g1)
sort(table(w$membership))



V(g1)$color <- rep("white", length(w$membership))
keepTheseCommunities <- names(sizes(w))[sizes(w) > 3]
matchIndex <- match(w$membership, keepTheseCommunities) # like %in%
colorVals <- rainbow(5)[matchIndex[!is.na(matchIndex)]]
V(g1)$color[!is.na(matchIndex)] <- colorVals


plot.igraph(g1, vertex.size=5)





